<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Agri Map Pro (Parallel AB Swaths; Last at C)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet & Draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="">
// --- Mobile-friendly Undo button (instead of right-click) ---
const btnUndo = document.createElement("button");
btnUndo.textContent = "Undo";
btnUndo.style.marginLeft = "8px";
btnUndo.addEventListener("click", () => {
  if (drawControl && drawControl._toolbars.draw._activeMode) {
    const layer = drawControl._toolbars.draw._activeMode.handler;
    if (layer._markers && layer._markers.length) {
      layer._markers.pop().remove();
    }
  }
});
document.querySelector(".toolbar")?.appendChild(btnUndo);

// --- Auto-collapse sidebar on small screens ---
const mq = window.matchMedia("(max-width: 900px)");
function handleMediaChange(e) {
  if (e.matches) {
    if (!appRoot.classList.contains("aside-collapsed")) {
      appRoot.classList.add("aside-collapsed");
      btnTogglePanel.setAttribute("aria-pressed", "true");
      setTimeout(() => map.invalidateSize(), 260);
    }
  } else {
    if (appRoot.classList.contains("aside-collapsed")) {
      appRoot.classList.remove("aside-collapsed");
      btnTogglePanel.setAttribute("aria-pressed", "false");
      setTimeout(() => map.invalidateSize(), 260);
    }
  }
}
mq.addEventListener("change", handleMediaChange);
handleMediaChange(mq);


// --- Auto-close sidebar on menu click or backdrop tap ---
document.querySelectorAll("aside button, aside a").forEach(el => {
  el.addEventListener("click", () => {
    if (window.matchMedia("(max-width: 900px)").matches) {
      appRoot.classList.add("aside-collapsed");
      btnTogglePanel.setAttribute("aria-pressed", "true");
      setTimeout(() => map.invalidateSize(), 260);
    }
  });
});
document.getElementById("sidebar-backdrop").addEventListener("click", () => {
  appRoot.classList.add("aside-collapsed");
  btnTogglePanel.setAttribute("aria-pressed", "true");
  setTimeout(() => map.invalidateSize(), 260);
});

</script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- Turf + tokml -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/tokml@0.4.0/tokml.js"></script>

  <style>
    :root{
      --bg:#f7f8fc; --card:#ffffff; --muted:#6b7280; --text:#0b1220;
      --accent:#22c55e; --accent-2:#3b82f6; --danger:#ef4444; --border:#e5e7eb;
      --shadow:0 6px 20px rgba(30,41,59,.08);
    }
    *{ box-sizing:border-box }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial }

    #app{ display:grid; grid-template-columns:360px 1fr; grid-template-rows:60px 1fr; height:100%; transition:grid-template-columns .25s ease; }
    header{
      grid-column:1/-1; display:flex; align-items:center; justify-content:space-between;
      padding:12px 16px; border-bottom:1px solid var(--border);
      background:linear-gradient(180deg,#ffffff,#f7f8fc)
    }
    .brand{ display:flex; align-items:center; gap:12px; font-weight:700; letter-spacing:.5px }
    .dot{ width:10px; height:10px; border-radius:50%; background:var(--accent); box-shadow:0 0 8px rgba(34,197,94,.6) }
    .tag{ font-size:12px; color:var(--muted) }

    .toolbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .toolbar button{
      background:#ffffff; color:var(--text); border:1px solid var(--border);
      padding:8px 10px; border-radius:8px; cursor:pointer; box-shadow:var(--shadow)
    }
    .toolbar button:hover{ background:#f3f4f6 }

    #app.aside-collapsed { grid-template-columns:0px 1fr; }
    #app.aside-collapsed aside { width:0; padding:0; border-right:0; overflow:hidden; }
    aside{ border-right:1px solid var(--border); padding:12px; background:linear-gradient(180deg,#ffffff,#f7f8fc); overflow:auto; transition:width .25s ease, padding .25s ease; }
    #btnTogglePanel[aria-pressed="true"]{ background:#f3f4f6; }

    .card{
      background:var(--card); border:1px solid var(--border); border-radius:12px;
      padding:12px; margin-bottom:12px; color:var(--text); box-shadow:var(--shadow)
    }
    .card h3{ margin:0 0 10px; font-size:14px; color:var(--text); text-transform:uppercase; letter-spacing:.6px }
    label{ font-size:12px; color:var(--text); display:block; margin:6px 0 4px }
    select,input[type=text],input[type=file],input[type=number]{
      width:100%; padding:10px; border-radius:10px; border:1px solid var(--border); background:#ffffff; color:var(--text)
    }

    .row{ display:flex; gap:8px } .row>*{ flex:1 }

    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      padding:10px 12px; border-radius:10px; border:1px solid var(--border);
      cursor:pointer; background:#ffffff; color:var(--text); box-shadow:var(--shadow)
    }
    .btn:hover{ background:#f3f4f6 }
    .btn.accent{ background:#ecfdf5; border-color:#86efac; color:#065f46 }
    .btn.blue{ background:#eff6ff; border-color:#93c5fd; color:#1e3a8a }
    .btn.danger{ background:#fef2f2; border-color:#fecaca; color:#7f1d1d }
    .btn.block{ width:100% }

    .hint{ font-size:12px; color:var(--muted); margin-top:8px }

    .list{ display:grid; gap:8px }
    .item{
      padding:8px; border:1px solid var(--border); border-radius:10px; background:#ffffff; color:var(--text);
      display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:8px; box-shadow:var(--shadow)
    }
    .item .meta{ font-size:12px; color:var(--muted) }
    .item .actions{ display:flex; gap:6px; flex-wrap:wrap }

    .pill{
      font-size:11px; border:1px solid var(--border); background:#f9fafb; color:var(--text);
      padding:4px 8px; border-radius:999px; box-shadow:var(--shadow)
    }
    .item input[type=checkbox]{ width:16px; height:16px }

    .btn.pill.merge-active{
      box-shadow: inset 0 2px 6px rgba(0,0,0,.08);
      transform: translateY(1px);
    }

    #map{ height:100%; width:100% }
    .footer-note{ font-size:11px; color:var(--muted); text-align:center; margin-top:6px }
    .divider{ height:1px; background:var(--border); margin:10px 0 }

    .k2j{ background:#ffffff; border:1px solid var(--border); border-radius:12px; padding:12px; color:var(--text); box-shadow:var(--shadow) }
    .k2j h4{ margin:0 0 8px; color:var(--text) }

    .leaflet-tooltip{
      background:#ffffff; color:#000;
      border:1px solid var(--border); border-radius:8px; padding:4px 8px; font-weight:700; box-shadow:var(--shadow)
    }
    .leaflet-control-layers,
    .leaflet-control-layers label,
    .leaflet-control-layers span{ color:#000 !important; }

    #patternToast{
      position:fixed; top:10px; left:50%; transform:translateX(-50%);
      background:#ffffff; border:1px solid var(--border); color:var(--text);
      padding:8px 12px; border-radius:10px; z-index:999; display:none; pointer-events:none; box-shadow:var(--shadow)
    }
    #patternToast .badge{
      margin-right:8px; background:#f1f5f9; border:1px solid var(--border); padding:2px 8px; border-radius:999px; color:var(--text)
    }
    .abc{ background:#eaf2ff; color:#1e3a8a; border:1px solid #93c5fd; padding:2px 6px; border-radius:6px; font-weight:700 }

    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.25); display:none; align-items:center; justify-content:center; z-index:1000 }
    .modal{
      width:520px; max-width:92vw; background:var(--card); border:1px solid var(--border); border-radius:12px;
      padding:14px; box-shadow:0 10px 30px rgba(2,6,23,.12); color:var(--text)
    }
    .modal h3{ margin:0 0 10px; color:var(--text) }
    .modal .row{ margin-top:8px }
    .modal .actions{ display:flex; gap:8px; margin-top:10px }
  
/* --- Mobile Enhancements --- */
@media (max-width: 900px) {
  aside {
    width: 100%;
    position: absolute;
    z-index: 1000;
    height: auto;
    max-height: 60%;
    overflow-y: auto;
  }
  #app.aside-collapsed aside {
    display: none;
  }
  .toolbar, .controls, .row {
    flex-direction: column;
    align-items: stretch;
  }
  button, select, input {
    font-size: 1.1rem;
    padding: 12px;
    margin: 4px 0;
    width: 100%;
  }
}
button {
  min-height: 44px;
  min-width: 44px;
}


/* --- Mobile Overlay Sidebar Fix --- */
@media (max-width: 900px) {
  #app {
    display: flex;
  }
  aside {
    position: fixed !important;
    top: 0;
    left: 0;
    width: 80%;
    max-width: 320px;
    height: 100%;
    background: #fff;
    z-index: 1000;
    box-shadow: 2px 0 5px rgba(0,0,0,0.3);
    transition: transform 0.3s ease;
    transform: translateX(0);
    overflow-y: auto;
  }
  #app.aside-collapsed aside {
    transform: translateX(-100%);
  }
  main {
    flex: 1;
    position: relative;
  }
  #btnTogglePanel {
    position: fixed !important;
    top: 10px;
    left: 10px;
    z-index: 1100;
    padding: 10px 14px;
    font-size: 20px;
    background: #fff;
    border: 1px solid #ccc;
    border-radius: 4px;
  }
  .leaflet-control-layers label {
    font-size: 1.1rem;
    padding: 10px;
  }
}


/* --- Mobile Sidebar Backdrop --- */
@media (max-width: 900px) {
  #sidebar-backdrop {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.3);
    z-index: 900;
  }
  #app:not(.aside-collapsed) #sidebar-backdrop {
    display: block;
  }
}

</style>
</head>
<body>
<div id="sidebar-backdrop"></div>
  <div id="app">
    <header>
      <div class="brand">
        <span class="dot"></span>
        <div>
          <div>Agri Map Pro</div>
          <div class="tag">Draw â€¢ Save â€¢ Export</div>
        </div>
      </div>
      <div class="toolbar">
        <button id="btnTogglePanel" aria-pressed="false" title="Show/Hide panel">Panel</button>
        <button id="btnDrawPoly">Draw polygon</button>
        <button id="btnCutPoly">Cut polygon</button>
        <button id="btnAddPattern">Add pattern</button>
        <button id="btnDeleteSelected" class="danger">Delete selected</button>
        <button id="btnClearPattern" class="danger">Clear swaths</button>
      </div>
    </header>

    <aside>
      <div class="card">
        <h3>Client Manager</h3>
        <label for="clientSelect">Active client</label>
        <select id="clientSelect"></select>
        <div class="row" style="margin-top:8px;">
          <button id="btnNewClient" class="btn accent">+ New</button>
          <button id="btnRenameClient" class="btn blue">Rename</button>
          <button id="btnDeleteClient" class="btn danger">Delete</button>
        </div>
        <div class="hint">Each client keeps their own set of saved fields (polygons).</div>
      </div>

      <div class="card">
        <h3>Polygons</h3>
        <div class="row" style="margin-bottom:8px;">
          <input id="polyName" type="text" placeholder="Field name (e.g. North 12ha)" />
          <button id="btnSavePolys" class="btn block accent">Save name</button>
        </div>
        <div class="list" id="polyList"></div>
        <div class="footer-note">Tick/untick to show or hide a polygon.</div>
      </div>

      <div class="card">
        <h3>Import / Export</h3>
        <div class="row" style="margin-bottom:4px;">
          <button id="btnExportKML" class="btn blue">Make JOB</button>
        </div>
        <div class="hint">Exports all <b>checked</b> polygons for the active client.</div>

        <label for="importKmlFile" style="margin-top:10px;">Import KML</label>
        <input type="file" id="importKmlFile" accept=".kml,application/vnd.google-earth.kml+xml" />
        <div class="hint">Imports polygons from KML into the active client.</div>
        <div class="divider"></div>
        <div class="footer-note">Data is auto-saved locally in your browser.</div>
      </div>

      <div class="card">
        <h3>Stats (selected)</h3>
        <div id="statsBox" class="hint">Select a polygon on the map to see area & perimeter.</div>
      </div>

      <div class="footer-note">Â© Agri Map Pro â€” Made By Gerhard Mostert </div>
    </aside>

    <main id="map"></main>
  </div>

  <div id="patternToast"><span class="badge">Pattern</span><span id="patternToastText"></span></div>

  <div id="patternModal" class="modal-backdrop">
    <div class="modal">
      <h3>Pattern settings</h3>
      <div class="row">
        <div>
          <label for="swathWidth">Swath width (m)</label>
          <input type="number" id="swathWidth" placeholder="Default 22" min="1" />
        </div>
        <div>
          <label for="patternType">Pattern type</label>
          <select id="patternType">
            <option value="RACETRACK" selected>Racetrack (AB parallel â†’ toward C)</option>
            <option value="BACK_TO_BACK">Back-to-back</option>
            <option value="QUICK">Quick</option>
            <option value="REVERSE_RACETRACK">Reverse Racetrack</option>
            <option value="SQUEEZE">Squeeze</option>
            <option value="EXPAND">Expand</option>
            <option value="QUICKTRACK_X">Quicktrack X</option>
          </select>
        </div>
      </div>
      <div class="actions">
        <button id="btnPatternGenerate" class="btn blue">Generate</button>
        <a id="downloadSwaths" class="btn accent" style="display:none" download="lines.kml">Download KML</a>
        <button id="btnPatternCancel" class="btn" style="margin-left:auto">Close</button>
      </div>
      <div id="patternResult" class="hint" style="margin-top:8px;"></div>
    </div>
  </div>

  <script>
    /* ---------- Utils ---------- */
    function download(filename, content, mime = 'text/plain') {
      const blob = new Blob([content], { type: mime });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }
    function fmt4(n){ return Number(n).toFixed(4); }
    function fmt6(n){ return Number(n).toFixed(6); }
    function getCurrentSwathWidth(){
      const v = (document.getElementById('swathWidth')?.value || localStorage.getItem('swathWidth') || '22').trim();
      const n = parseFloat(v);
      return isNaN(n) || n <= 0 ? 22 : n;
    }

    /* ---------- Right-click undo while drawing ---------- */
    let activeDrawHandler = null;
    function onRightClickUndo(e){
      if (activeDrawHandler && typeof activeDrawHandler.deleteLastVertex === 'function') {
        activeDrawHandler.deleteLastVertex();
      }
      if (e && e.originalEvent) e.originalEvent.preventDefault(); // stop context menu
    }
    function enableUndo(handler){
      activeDrawHandler = handler;
      map.on('contextmenu', onRightClickUndo);
    }
    function disableUndo(){
      map.off('contextmenu', onRightClickUndo);
      activeDrawHandler = null;
    }

    /* ---------- Storage ---------- */
    const LS_CLIENTS='agrimappro.clients', LS_CLIENT_DATA_PREFIX='agrimappro.client.';
    const uid=()=>Math.random().toString(36).slice(2,10);
    const keyForClient=id=>`${LS_CLIENT_DATA_PREFIX}${id}.features`;
    const loadClients=()=>{ try{return JSON.parse(localStorage.getItem(LS_CLIENTS))||[]}catch{return[]} };
    const saveClients=v=>localStorage.setItem(LS_CLIENTS, JSON.stringify(v));
    const loadClientFeatures=id=>{ try{return JSON.parse(localStorage.getItem(keyForClient(id)))||{type:'FeatureCollection',features:[]}}catch{return{type:'FeatureCollection',features:[]}} };
    const saveClientFeatures=(id,fc)=>localStorage.setItem(keyForClient(id), JSON.stringify(fc));

    /* ---------- Map ---------- */
    const map=L.map('map',{zoomControl:true}).setView([-25.8,28.2],7);
    const streets=L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:20,attribution:'&copy; OpenStreetMap'});
    const satellite=L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',{maxZoom:19,attribution:'Tiles Â© Esri / Maxar'}).addTo(map);
    const labels=L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',{maxZoom:19,attribution:'Esri Reference'});
    const drawnItems=L.featureGroup().addTo(map);
    const patternLayer=L.featureGroup().addTo(map);
    L.control.layers({'Satellite (Esri)':satellite,'Streets (OSM)':streets},{'Labels':labels,'Fields (your polygons)':drawnItems,'Pattern lines':patternLayer},{collapsed:false}).addTo(map);

    const drawControl=new L.Control.Draw({
      edit:{featureGroup:drawnItems, edit:false, remove:false},
      draw:{polyline:false, rectangle:false, circle:false, circlemarker:false, marker:false,
        polygon:{allowIntersection:false, showArea:true, shapeOptions:{color:'#5b8def', weight:2}}}
    });
    map.addControl(drawControl);

    let selectedLayer=null;
    const idToLayer=new Map();

    /* ---------- Selection helpers ---------- */
    function isPatternLine(layer){ return !!layer && (layer instanceof L.Polyline) && !(layer instanceof L.Polygon) && patternLayer.hasLayer(layer); }
    function setSelectedStyle(layer,on){
      if(!layer?.setStyle) return;
      if(isPatternLine(layer)){ layer.setStyle({ weight:on?5:2, color:on?'#16a34a':'#22c55e' }); }
      else { layer.setStyle({ weight:on?4:2, color:on?'#2563eb':'#5b8def' }); }
    }
    function clearSelected(){ if(selectedLayer){ setSelectedStyle(selectedLayer,false); } selectedLayer=null; updateStats(); }
    function selectLayer(layer){ clearSelected(); selectedLayer=layer; setSelectedStyle(layer,true); updateStats(layer); }
    function ensureIdOnFeature(f){ f.properties=f.properties||{}; if(!f.properties.id) f.properties.id=uid(); return f; }
    function applyNameTooltip(layer, name){
      if (!layer?.bindTooltip) return;
      try{ layer.unbindTooltip?.(); }catch{}
      layer.bindTooltip(name || 'Field', {permanent:true, direction:'center', className:'leaflet-tooltip'});
    }
    function layerFromFeature(feature){
      const layer=L.geoJSON(feature,{style:{color:'#5b8def', weight:2}});
      let added;
      layer.eachLayer(l=>{ added=l; added._featureId=feature.properties.id; drawnItems.addLayer(added); attachLayerHandlers(added); });
      idToLayer.set(feature.properties.id, added);
      const nm = feature.properties?.name || 'Field';
      applyNameTooltip(added, nm);
      return added;
    }
    function attachLayerHandlers(layer){
      layer.on('click',()=>selectLayer(layer));
      layer.on('mouseover',()=>{ if(selectedLayer!==layer) layer.setStyle({color:'#2563eb'}); });
      layer.on('mouseout',()=>{ if(selectedLayer!==layer) layer.setStyle({color:'#5b8def'}); });
    }
    function attachPatternLineHandlers(line){
      line.on('click',()=>selectLayer(line));
      line.on('mouseover',()=>{ if(selectedLayer!==line) line.setStyle({color:'#16a34a'}); });
      line.on('mouseout',()=>{ if(selectedLayer!==line) line.setStyle({color:'#22c55e'}); });
    }

    /* ---------- UI refs ---------- */
    const clientSelect=document.getElementById('clientSelect');
    const btnNewClient=document.getElementById('btnNewClient');
    const btnRenameClient=document.getElementById('btnRenameClient');
    const btnDeleteClient=document.getElementById('btnDeleteClient');
    const btnDrawPoly=document.getElementById('btnDrawPoly');
    const btnCutPoly=document.getElementById('btnCutPoly');
    const btnAddPattern=document.getElementById('btnAddPattern');
    const btnDeleteSelected=document.getElementById('btnDeleteSelected');
    const btnClearPattern=document.getElementById('btnClearPattern');
    const polyNameInput=document.getElementById('polyName');
    const btnSavePolys=document.getElementById('btnSavePolys');
    const polyList=document.getElementById('polyList');
    const btnExportKML=document.getElementById('btnExportKML');
    const importKmlFile=document.getElementById('importKmlFile');
    const statsBox=document.getElementById('statsBox');

    const toastEl=document.getElementById('patternToast');
    const toastText=document.getElementById('patternToastText');
    const modal=document.getElementById('patternModal');
    const btnPatternGenerate=document.getElementById('btnPatternGenerate');
    const btnPatternCancel=document.getElementById('btnPatternCancel');
    const swathWidthInput=document.getElementById('swathWidth');
    const patternTypeSelect=document.getElementById('patternType');
    const downloadSwaths=document.getElementById('downloadSwaths');
    const resultBox=document.getElementById('patternResult');

    /* ---------- Clients ---------- */
    let clients=loadClients(); let activeClientId=null;
    function ensureDefaultClient(){ if(clients.length===0){ const c={id:uid(), name:'Client A'}; clients=[c]; saveClients(clients); saveClientFeatures(c.id,{type:'FeatureCollection',features:[]}); } }
    function refreshClientSelect(){
      clientSelect.innerHTML='';
      clients.forEach(c=>{ const opt=document.createElement('option'); opt.value=c.id; opt.textContent=c.name; clientSelect.appendChild(opt); });
      if(!activeClientId||!clients.find(c=>c.id===activeClientId)) activeClientId=clients[0]?.id||null;
      clientSelect.value=activeClientId||'';
    }
    function loadClientIntoMap(){
      drawnItems.clearLayers(); idToLayer.clear(); clearSelected();
      if(!activeClientId) return;
      const fc=loadClientFeatures(activeClientId);
      fc.features=(fc.features||[]).map(ensureIdOnFeature);
      saveClientFeatures(activeClientId, fc);
      for(const f of fc.features){ if(f.properties.visible===false) continue; layerFromFeature(f); }
      fitIfAny(); renderPolyList();
    }
    function fitIfAny(){
      const layers=[...drawnItems.getLayers(), ...patternLayer.getLayers()];
      if(layers.length){ map.fitBounds(L.featureGroup(layers).getBounds(), {padding:[20,20]}); }
    }

    btnNewClient.addEventListener('click',()=>{ const name=prompt('New client name:'); if(!name) return; const c={id:uid(), name:name.trim()}; clients.push(c); saveClients(clients); saveClientFeatures(c.id,{type:'FeatureCollection',features:[]}); activeClientId=c.id; refreshClientSelect(); loadClientIntoMap(); });
    btnRenameClient.addEventListener('click',()=>{ const cur=clients.find(c=>c.id===activeClientId); if(!cur) return; const v=prompt('Rename client:', cur.name); if(!v) return; cur.name=v.trim(); saveClients(clients); refreshClientSelect(); });
    btnDeleteClient.addEventListener('click',()=>{ const cur=clients.find(c=>c.id===activeClientId); if(!cur) return; if(!confirm(`Delete "${cur.name}" and all polygons?`)) return; localStorage.removeItem(keyForClient(cur.id)); clients=clients.filter(c=>c.id!==cur.id); saveClients(clients); ensureDefaultClient(); activeClientId=clients[0]?.id||null; refreshClientSelect(); loadClientIntoMap(); });
    clientSelect.addEventListener('change',()=>{ activeClientId=clientSelect.value; loadClientIntoMap(); });

    /* ---------- Draw / Save / Cut Polygons ---------- */
    let cutMode=false;

    map.on(L.Draw.Event.CREATED,(e)=>{
      disableUndo(); // stop right-click undo once a shape is finished
      const layer=e.layer;
      const base=layer.toGeoJSON();

      // Cut mode: subtract cutter from selected polygon
      if (cutMode) {
        try {
          if (!selectedLayer || isPatternLine(selectedLayer)) {
            alert('Select a polygon to cut first.');
            layer.remove();
            cutMode=false; hideToast();
            return;
          }
          const target = selectedLayer.toGeoJSON();
          if (!target?.geometry || !target.geometry.type.includes('Polygon')) {
            alert('Selected layer is not a polygon.');
            layer.remove();
            cutMode=false; hideToast();
            return;
          }

          const cutter = base;
          const diff = turf.difference(turf.feature(target.geometry), turf.feature(cutter.geometry));

          const id = selectedLayer._featureId;
          const fc = loadClientFeatures(activeClientId);
          const old = fc.features.find(f => f.properties.id === id);
          const baseName = old?.properties?.name || 'Field';

          // remove old feature
          fc.features = fc.features.filter(f => f.properties.id !== id);
          drawnItems.removeLayer(selectedLayer);
          idToLayer.delete(id);
          clearSelected();

          if (diff && diff.geometry) {
            // Normalize to Polygon pieces
            let geoms = [];
            if (diff.geometry.type === 'Polygon' || diff.geometry.type === 'MultiPolygon') {
              geoms = [diff.geometry];
            } else if (diff.geometry.type === 'GeometryCollection') {
              geoms = (diff.geometry.geometries || []).filter(g => g.type === 'Polygon' || g.type === 'MultiPolygon');
            }

            const polys = [];
            geoms.forEach(g=>{
              if (g.type === 'Polygon') polys.push(g);
              else if (g.type === 'MultiPolygon') {
                g.coordinates.forEach(coords => polys.push({ type:'Polygon', coordinates: coords }));
              }
            });

            polys.forEach((geom, idx)=>{
              const f = turf.feature(geom, {
                id: uid(),
                name: polys.length>1 ? `${baseName} part ${idx+1}` : baseName,
                visible: true,
                savedAt: new Date().toISOString()
              });
              fc.features.push(f);
              const lyr = layerFromFeature(f);
              if (idx === 0) selectLayer(lyr);
            });

            saveClientFeatures(activeClientId, fc);
            renderPolyList();
            fitIfAny();
            alert('Cut applied.');
          } else {
            saveClientFeatures(activeClientId, fc);
            renderPolyList();
            fitIfAny();
            alert('Cut removed the entire polygon. It has been deleted.');
          }
        } catch (err) {
          console.error(err);
          alert('Cut failed. Ensure the cut shape overlaps the polygon.');
        } finally {
          cutMode=false;
          hideToast();
        }
        return;
      }

      // Normal create new field
      const fc=loadClientFeatures(activeClientId);
      const f={
        type:'Feature',
        geometry:base.geometry,
        properties:{ name:(polyNameInput.value||'').trim()||`Field ${fc.features.length+1}`, visible:true, savedAt:new Date().toISOString() }
      };
      ensureIdOnFeature(f);
      fc.features.push(f); saveClientFeatures(activeClientId, fc);
      layer._featureId=f.properties.id; attachLayerHandlers(layer); drawnItems.addLayer(layer); idToLayer.set(f.properties.id, layer);
      applyNameTooltip(layer, f.properties.name);
      selectLayer(layer); renderPolyList();
    });

    /* Prompt for client name â†’ switch/create â†’ enable drawing */
    btnDrawPoly.addEventListener('click', () => {
      const suggested = clients.find(c=>c.id===activeClientId)?.name || '';
      const name = (prompt('Enter client name for this polygon:', suggested) || '').trim();
      if (!name) return;

      let client = clients.find(c => c.name.toLowerCase() === name.toLowerCase());
      if (!client) {
        client = { id: uid(), name };
        clients.push(client);
        saveClientFeatures(client.id, { type: 'FeatureCollection', features: [] });
      }
      activeClientId = client.id;
      refreshClientSelect();
      loadClientIntoMap();

      const handler = new L.Draw.Polygon(map, drawControl.options.draw.polygon);
      handler.enable();
      enableUndo(handler);
      showToast('Drawing: left-click add, right-click undo, double-click finish');
      setTimeout(()=>hideToast(), 3000);
    });

    /* ---------- CUT polygon button ---------- */
    btnCutPoly.addEventListener('click', ()=>{
      if (!selectedLayer || isPatternLine(selectedLayer)) {
        alert('Select a polygon to cut first.');
        return;
      }
      const isPoly = selectedLayer.toGeoJSON()?.geometry?.type?.includes('Polygon');
      if (!isPoly) { alert('Selected layer is not a polygon.'); return; }
      cutMode = true;
      const handler = new L.Draw.Polygon(map, drawControl.options.draw.polygon);
      handler.enable();
      enableUndo(handler);
      toastText.textContent = 'Cut mode: draw a polygon to subtract â€¢ Right-click = undo';
      toastEl.style.display = 'block';
    });

    /* ---------- Delete / Clear swaths ---------- */
    btnDeleteSelected.addEventListener('click', () => {
      if (!selectedLayer) return alert('Select a polygon or a pattern line first.');
      if (isPatternLine(selectedLayer)) {
        if (!confirm('Delete the selected pattern line?')) return;
        patternLayer.removeLayer(selectedLayer);
        selectedLayer = null; updateStats(); return;
      }
      const id = selectedLayer._featureId;
      const fc = loadClientFeatures(activeClientId);
      fc.features = fc.features.filter(f => f.properties.id !== id);
      saveClientFeatures(activeClientId, fc);
      drawnItems.removeLayer(selectedLayer);
      idToLayer.delete(id);
      selectedLayer = null; renderPolyList(); updateStats();
    });

    btnClearPattern.addEventListener('click', () => {
      const count = patternLayer.getLayers().length;
      if (!count) return alert('No swath lines to clear.');
      if (!confirm(`Delete ALL swath lines (${count})?`)) return;
      patternLayer.clearLayers();
      if (selectedLayer && isPatternLine(selectedLayer)) selectedLayer = null;
      updateStats();
    });

    btnSavePolys.addEventListener('click',()=>{
      const name=(polyNameInput.value||'').trim();
      if(!name||!selectedLayer){ alert('Select a polygon and enter a name.'); return; }
      if(isPatternLine(selectedLayer)){ alert('Rename applies to polygons only.'); return; }
      const id=selectedLayer._featureId;
      const fc=loadClientFeatures(activeClientId);
      const f=fc.features.find(x=>x.properties.id===id);
      if(f){
        f.properties.name=name;
        f.properties.savedAt=new Date().toISOString();
        saveClientFeatures(activeClientId, fc);
        selectedLayer.feature=selectedLayer.feature||{type:'Feature',properties:{}};
        selectedLayer.feature.properties.name=name;
        applyNameTooltip(selectedLayer, name);
        renderPolyList(); polyNameInput.value=''; alert('Saved.');
      }
    });

    /* ---------- Merge mode state ---------- */
    let mergeState = { firstId: null, firstBtn: null };

    function resetMergeState(){
      if(mergeState.firstBtn){ mergeState.firstBtn.classList.remove('merge-active'); mergeState.firstBtn.textContent = 'merge'; }
      mergeState = { firstId:null, firstBtn:null };
    }

    function mergePolygonsById(id1, id2){
      if(id1 === id2) return;

      const fc = loadClientFeatures(activeClientId);
      const f1 = fc.features.find(f => f.properties.id === id1);
      const f2 = fc.features.find(f => f.properties.id === id2);
      if(!f1 || !f2) { resetMergeState(); return alert('Could not find both polygons.'); }

      try{
        const merged = turf.union(
          turf.feature(f1.geometry, f1.properties),
          turf.feature(f2.geometry, f2.properties)
        );
        if(!merged) throw new Error('Union failed');

        const newFeature = turf.feature(merged.geometry, {
          id: uid(),
          name: `${(f1.properties.name||'Field')} + ${(f2.properties.name||'Field')}`,
          visible: true,
          savedAt: new Date().toISOString()
        });

        // Update storage
        fc.features = fc.features.filter(f => f.properties.id !== id1 && f.properties.id !== id2);
        fc.features.push(newFeature);
        saveClientFeatures(activeClientId, fc);

        // Update map layers
        const l1 = idToLayer.get(id1);
        const l2 = idToLayer.get(id2);
        if(l1){ if(selectedLayer===l1) clearSelected(); drawnItems.removeLayer(l1); idToLayer.delete(id1); }
        if(l2){ if(selectedLayer===l2) clearSelected(); drawnItems.removeLayer(l2); idToLayer.delete(id2); }

        const addedLayer = layerFromFeature(newFeature);
        selectLayer(addedLayer);
        renderPolyList();
        fitIfAny();
      }catch(err){
        console.error(err);
        alert('Merge failed (topology issue). Make sure polygons touch or overlap.');
      }finally{
        resetMergeState();
      }
    }

    function renderPolyList(){
      polyList.innerHTML='';
      const fc=activeClientId?loadClientFeatures(activeClientId):{features:[]};
      fc.features.forEach((f,idx)=>{
        ensureIdOnFeature(f);
        const id=f.properties.id, name=f.properties.name||`Field ${idx+1}`;
        const area=(turf.area(f)/10000).toFixed(2);
        const perim=(turf.length(turf.polygonToLine(f),{units:'meters'})).toFixed(0);
        const vis=f.properties.visible!==false;

        const row=document.createElement('div'); row.className='item';
        const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=vis;

        const left=document.createElement('div');
        left.innerHTML=`<strong style="color:var(--text)">${name}</strong><div class="meta">${area} ha â€¢ ${perim} m</div>`;

        const actions=document.createElement('div'); actions.className='actions';
        const bMerge=document.createElement('button'); bMerge.className='btn pill'; bMerge.textContent='merge';
        const bRen=document.createElement('button'); bRen.className='btn pill'; bRen.textContent='rename';
        const bDel=document.createElement('button'); bDel.className='btn pill danger'; bDel.textContent='delete';
        actions.append(bMerge,bRen,bDel);

        row.append(chk,left,actions); polyList.appendChild(row);

        chk.addEventListener('change',()=>{
          const fc2=loadClientFeatures(activeClientId);
          const f2=fc2.features.find(x=>x.properties.id===id); if(!f2) return;
          if(chk.checked){
            f2.properties.visible=true; saveClientFeatures(activeClientId, fc2);
            if(!idToLayer.has(id)) {
              const lyr = layerFromFeature(f2);
              if (selectedLayer && selectedLayer._featureId===id) selectLayer(lyr);
            }
          } else {
            f2.properties.visible=false; saveClientFeatures(activeClientId, fc2);
            const layer=idToLayer.get(id);
            if(layer){ if(selectedLayer===layer) clearSelected(); drawnItems.removeLayer(layer); idToLayer.delete(id); }
            if(mergeState.firstId === id) resetMergeState();
          }
        });

        // Merge logic
        bMerge.addEventListener('click',()=>{
          if(!chk.checked){
            return alert('Show this polygon first to merge.');
          }
          if(!mergeState.firstId){
            mergeState.firstId = id;
            mergeState.firstBtn = bMerge;
            bMerge.classList.add('merge-active');
            bMerge.textContent = 'selected';
          }else if(mergeState.firstId === id){
            resetMergeState();
          }else{
            mergePolygonsById(mergeState.firstId, id);
          }
        });

        bRen.addEventListener('click',()=>{
          const v=prompt('New field name:', name); if(!v) return;
          const fc2=loadClientFeatures(activeClientId);
          const f2=fc2.features.find(x=>x.properties.id===id);
          if(f2){
            f2.properties.name=v.trim(); f2.properties.savedAt=new Date().toISOString(); saveClientFeatures(activeClientId, fc2);
            const layer=idToLayer.get(id);
            if(layer){ layer.feature=layer.feature||{type:'Feature',properties:{}}; layer.feature.properties.name=f2.properties.name; applyNameTooltip(layer, f2.properties.name); }
            renderPolyList();
          }
          if(mergeState.firstId === id) resetMergeState();
        });

        bDel.addEventListener('click',()=>{
          if(!confirm(`Delete polygon "${name}"?`)) return;
          const fc2=loadClientFeatures(activeClientId);
          fc2.features=fc2.features.filter(x=>x.properties.id!==id); saveClientFeatures(activeClientId, fc2);
          const layer=idToLayer.get(id);
          if(layer){ if(selectedLayer===layer) clearSelected(); drawnItems.removeLayer(layer); idToLayer.delete(id); }
          renderPolyList(); updateStats();
          if(mergeState.firstId === id) resetMergeState();
        });
      });

      if(fc.features.length===0){
        const empty=document.createElement('div'); empty.className='hint';
        empty.innerHTML='No polygons yet. Click <b>Draw polygon</b> to start.'; polyList.appendChild(empty);
      }
    }

    function updateStats(layer=null){
      const feature=layer?layer.toGeoJSON():null;
      if(!feature){ statsBox.innerHTML='Select a polygon on the map to see area & perimeter.'; return; }
      if(isPatternLine(layer)){
        statsBox.innerHTML='<div><strong>Pattern line</strong></div><div class="hint">Parallel to AB, spaced by swath width, last at C.</div>';
        return;
      }
      const area=turf.area(feature)/10000;
      const perim=turf.length(turf.polygonToLine(feature),{units:'meters'});
      const name=(layer.feature?.properties?.name)||'Field';
      statsBox.innerHTML=`<div><strong>${name}</strong></div><div class="hint">Area: ${area.toFixed(2)} ha</div><div class="hint">Perimeter: ${perim.toFixed(0)} m</div>`;
    }

    /* ---------- Export helpers ---------- */
    function getVisibleFeaturesForActiveClient() {
      if (!activeClientId) return { type:'FeatureCollection', features: [] };
      const fc = loadClientFeatures(activeClientId);
      const visible = (fc.features || []).filter(f => f?.properties?.visible !== false);
      return { type:'FeatureCollection', features: visible };
    }

    /* ---------- Export / Import ---------- */
    btnExportKML.addEventListener('click',()=>{
      if(!activeClientId) return;

      const client = clients.find(c=>c.id===activeClientId);
      const exportFC = getVisibleFeaturesForActiveClient();

      if (!exportFC.features.length) {
        alert('No polygons are shown. Tick at least one polygon to export.');
        return;
      }

      // KML (all visible)
      const kml = tokml(exportFC, { name: 'name' });
      const kmlName = ((client?.name || 'client').replace(/\s+/g,'_')) + '.kml';
      download(kmlName, kml, 'application/vnd.google-earth.kml+xml');

      // JOB export (same visible set)
      let jobNumber = prompt('Enter Job Number (digits only):');
      if (jobNumber === null) return; // cancelled
      jobNumber = jobNumber.trim();
      if (!/^[0-9]+$/.test(jobNumber)) { alert('Please enter digits only.'); return; }

      const tmpKml = tokml(exportFC, { name: 'name' });
      autoConvertToJOB(tmpKml, client?.name || 'AutoClient', jobNumber);
    });

    // Import KML â†’ polygons
    importKmlFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file || !activeClientId) return;

      const reader = new FileReader();
      reader.onload = () => {
        try {
          const xml = new DOMParser().parseFromString(reader.result, "text/xml");
          const polygons = [...xml.getElementsByTagName("Polygon")];
          if (!polygons.length) return alert("No <Polygon> elements found.");

          const fc = loadClientFeatures(activeClientId);
          let added = 0;

          polygons.forEach((polygon) => {
            const outer = polygon.getElementsByTagName("outerBoundaryIs")[0] || polygon;
            const coordsEl = outer.getElementsByTagName("coordinates")[0];
            if (!coordsEl) return;

            let ring = coordsEl.textContent.trim().split(/\s+/).map(s => {
              const [lon, lat] = s.split(",").map(Number);
              return [lon, lat];
            });
            if (ring.length && (ring[0][0] !== ring[ring.length-1][0] || ring[0][1] !== ring[ring.length-1][1])) {
              ring.push([...ring[0]]);
            }

            if (ring.length >= 4) {
              const poly = turf.polygon([ring]);
              const f = turf.feature(poly.geometry, {
                id: uid(),
                name: `Imported ${fc.features.length + 1}`,
                visible: true,
                savedAt: new Date().toISOString()
              });
              fc.features.push(f);
              layerFromFeature(f);
              added++;
            }
          });

          saveClientFeatures(activeClientId, fc);
          renderPolyList(); fitIfAny();
          alert(`Imported ${added} polygon(s).`);
        } catch {
          alert("Invalid KML file.");
        }
      };
      reader.readAsText(file);
    });

    /* ---------- Guided Pattern ---------- */
    const abcIcon=label=>L.divIcon({ className:'abc', html:label, iconSize:[24,24], iconAnchor:[12,12] });

    // Keep a snapshot of last generated A/B/C for .PAT
    let patternState={ active:false, step:'idle', A:null, B:null, C:null, markers:[], listener:null };
    let lastPatternABC = null; // { A:{lat,lon}, B:{lat,lon}, C:{lat,lon}, sw:number, type:string }

    function showToast(text){ toastText.textContent=text; toastEl.style.display='block'; }
    function hideToast(){ toastEl.style.display='none'; }

    function startPattern(){
      patternState.markers.forEach(m=>map.removeLayer(m));
      patternLayer.clearLayers();

      patternState={ active:true, step:'A', A:null, B:null, C:null, markers:[], listener:null };
      showToast('Tap the map to place A');
      if(patternState.listener) map.off('click', patternState.listener);
      patternState.listener = (e)=>{
        const {lat,lng}=e.latlng;
        if(patternState.step==='A'){
          patternState.A={lat,lon:lng};
          patternState.markers.push(L.marker([lat,lng],{icon:abcIcon('A')}).addTo(map));
          patternState.step='B'; showToast('Tap to place B');
        } else if(patternState.step==='B'){
          patternState.B={lat,lon:lng};
          patternState.markers.push(L.marker([lat,lng],{icon:abcIcon('B')}).addTo(map));
          patternState.step='C'; showToast('Tap to place C');
        } else if(patternState.step==='C'){
          patternState.C={lat,lon:lng};
          patternState.markers.push(L.marker([lat,lng],{icon:abcIcon('C')}).addTo(map));
          map.off('click', patternState.listener); patternState.listener=null; hideToast(); openPatternConfig();
        }
      };
      map.on('click', patternState.listener);
    }

    function makeLocalProjector(A){
      const Rlat = 111320;
      const Rlon = 111320 * Math.cos((A.lat*Math.PI)/180);
      return {
        toXY: (p) => ({ x: (p.lon - A.lon) * Rlon, y: (p.lat - A.lat) * Rlat }),
        toLL: (pt) => ({ lat: A.lat + pt.y / Rlat, lon: A.lon + pt.x / Rlon })
      };
    }

    // Close modal WITHOUT clearing A/B/C
    function cancelPattern(){
      hideToast();
      if(patternState.listener){ map.off('click', patternState.listener); patternState.listener=null; }
      document.getElementById('patternModal').style.display='none';
    }

    function openPatternConfig(){
      swathWidthInput.value = localStorage.getItem('swathWidth') || swathWidthInput.value || '22';
      resultBox.textContent=''; downloadSwaths.style.display='none';
      document.getElementById('patternModal').style.display='flex';
    }

    document.getElementById('btnAddPattern').addEventListener('click', startPattern);
    btnPatternCancel.addEventListener('click', cancelPattern);

    swathWidthInput.addEventListener('input', () => {
      const v = (swathWidthInput.value||'').trim();
      if (v) localStorage.setItem('swathWidth', v);
    });

    let swathUrl=null;
    btnPatternGenerate.addEventListener('click', ()=>{
  const {A,B,C}=patternState; if(!A||!B||!C){ alert('Place A, B and C first.'); return; }
  const sw=parseFloat(swathWidthInput.value||'22'); if(isNaN(sw)||sw<=0){ alert('Enter a valid swath width (m).'); return; }

  // Snapshot for JOB export (.PAT), including pattern type
  lastPatternABC = { A:{...A}, B:{...B}, C:{...C}, sw, type: patternTypeSelect.value };

  // ðŸš€ Generate full swaths, stop only at C (no polygon clipping)
  let lines=buildPatternLines_A_B_C(A,B,C,sw);

  patternLayer.clearLayers();

  lines.forEach((ln,i)=>{
  const line=L.polyline([
    [ln.start.lat, ln.start.lon],
    [ln.mid.lat,   ln.mid.lon],
    [ln.end.lat,   ln.end.lon]
  ], {color:'#22c55e',weight:2})
    .addTo(patternLayer).bindTooltip(`Line ${i+1}`);
  attachPatternLineHandlers(line);
});

  const kml=buildKML(lines);
  const blob=new Blob([kml],{type:'application/vnd.google-earth.kml+xml'});
  if(swathUrl) URL.revokeObjectURL(swathUrl);
  swathUrl=URL.createObjectURL(blob);
  downloadSwaths.href=swathUrl;
  downloadSwaths.style.display='inline-block';
  resultBox.innerHTML=`<span style="color:#16a34a">Generated ${lines.length} swath(s).</span>`;
  fitIfAny();
});

    window.addEventListener('beforeunload', ()=>{ if(swathUrl) URL.revokeObjectURL(swathUrl); });

      function buildPatternLines_A_B_C(A,B,C,sw){
  const {toXY, toLL} = makeLocalProjector(A);
  const a = toXY(A), b = toXY(B), c = toXY(C);

  // Vector AB (spray direction)
  const ab = { x: b.x - a.x, y: b.y - a.y };
  const abLen = Math.hypot(ab.x, ab.y) || 1;
  const abUnit = { x: ab.x/abLen, y: ab.y/abLen };

  // Normal direction (sideways, oriented toward C)
  let n = { x: -abUnit.y, y: abUnit.x };
  const vecAC = { x: c.x - a.x, y: c.y - a.y };
  if (vecAC.x * n.x + vecAC.y * n.y < 0) { n.x *= -1; n.y *= -1; }

  // Distance from A to C along normal
  const total = Math.abs(vecAC.x * n.x + vecAC.y * n.y);
  const stepCount = Math.max(1, Math.round(total / sw));

  const lines = [];
  for (let i = 0; i <= stepCount; i++) {
    const d = Math.min(total, i * sw);
    const offset = { x: n.x * d, y: n.y * d };

    // Shift A, B, C sideways by offset
    const aXY = { x: a.x + offset.x, y: a.y + offset.y };
    const bXY = { x: b.x + offset.x, y: b.y + offset.y };
    const cXY = { x: c.x + offset.x, y: c.y + offset.y };

    lines.push({
      start: toLL(aXY),
      mid:   toLL(bXY),
      end:   toLL(cXY)
    });
  }
  return lines;
}




    function lineToFeature(ln) {
      return turf.lineString([[ln.start.lon, ln.start.lat], [ln.end.lon, ln.end.lat]]);
    }
    function midpointOfLine(line) {
      const len = turf.length(line);
      return turf.along(line, len / 2);
    }
    function clipLineToPolygon(ln, polyFeature) {
      const line = lineToFeature(ln);
      const split = turf.lineSplit(line, turf.polygonToLine(polyFeature));
      const kept = [];
      (split.features.length ? split.features : [line]).forEach(seg => {
        const mid = midpointOfLine(seg);
        if (turf.booleanPointInPolygon(mid, polyFeature)) kept.push(seg);
      });
      return kept.map(seg => {
        const [a, b] = seg.geometry.coordinates;
        return { start: { lat: a[1], lon: a[0] }, end: { lat: b[1], lon: b[0] } };
      });
    }

    function buildKML(lines){
      const head=`<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2"><Document>`;
      const color = 'ff5ec522'; // aabbggrr for #22c55e
      const body=lines.map((ln,i)=>`\n  <Placemark>\n    <name>Line ${i+1}</name>\n    <Style><LineStyle><color>${color}</color><width>2</width></LineStyle></Style>\n    <LineString><coordinates>\n      ${ln.start.lon},${ln.start.lat},0\n      ${ln.end.lon},${ln.end.lat},0\n    </coordinates></LineString>\n  </Placemark>`).join('');
      return head+body+'\n</Document></kml>';
    }

    /* ---------- KML -> JOB (auto, no UI) ---------- */
    function autoConvertToJOB(kmlText, clientName, forcedJobId){
      const jobId = String(forcedJobId || 'AutoJob');
      const cname = clientName || 'AutoClient';
      let output = `.JOB ${jobId} ${cname}\n.VERSION 1\n`;

      // --- POLYGONS (visible/export set) ---
      const parser = new DOMParser();
      const xml = parser.parseFromString(kmlText,"text/xml");
      const polygons = xml.getElementsByTagName("Polygon");
      let polyNumber=1;
      for(let polygon of polygons){
        const coords=polygon.getElementsByTagName("coordinates")[0];
        if(!coords) continue;
        const coordLines = coords.textContent.trim().split(/\s+/);
        output+=`.POL ${polyNumber} #${polyNumber}\n\tINC\n`;
        coordLines.forEach(line=>{
          const [lon,lat]=line.split(",");
          if(lat&&lon) output+=`\t${lat} ${lon}\n`;
        });
        polyNumber++;
      }

      // --- PATTERN (use last generated A/B/C & type if available) ---
      const pat = lastPatternABC || (patternState?.A && patternState?.B && patternState?.C ? {
        A: patternState.A, B: patternState.B, C: patternState.C, sw: getCurrentSwathWidth(), type: patternTypeSelect.value
      } : null);

      if (pat && pat.A && pat.B && pat.C) {
        const type = (pat.type || document.getElementById('patternType')?.value || 'RACETRACK');
        const side = 'RIGHT';     // fixed unless you add a dropdown
        const sw   = isNaN(pat.sw) ? getCurrentSwathWidth() : pat.sw;

        output += `.PAT 1 #1\n`;
        output += `\t${type}\n`;
        output += `\t${side}\n`;
        output += `\tSWIDTH ${fmt4(sw)}\n`;
        output += `\tFIELD_WIDTH\n`;
        output += `\tOFFSET 0.0000\n`;
        output += `\tABLINES   1\n`;
        output += `\tA ${fmt6(pat.A.lat)} ${fmt6(pat.A.lon)}\n`;
        output += `\tB ${fmt6(pat.B.lat)} ${fmt6(pat.B.lon)}\n`;
        output += `\tC ${fmt6(pat.C.lat)} ${fmt6(pat.C.lon)}\n`;
      }

      // --- Download ---
      const blob=new Blob([output],{type:"application/octet-stream"});
      const link=document.createElement("a");
      link.href=URL.createObjectURL(blob);
      link.download=`${jobId}.job`;
      document.body.appendChild(link);
      link.click();
      setTimeout(()=>{ URL.revokeObjectURL(link.href); link.remove(); },0);
    }

    /* ---------- Init & UI tweaks ---------- */
    function init(){ ensureDefaultClient(); refreshClientSelect(); loadClientIntoMap(); }
    init();

    map.on('click', (e)=>{ if(!e.originalEvent || !e.originalEvent.target || !e.originalEvent.target.closest || !e.originalEvent.target.closest('.leaflet-interactive')) clearSelected(); });

    const btnTogglePanel = document.getElementById('btnTogglePanel');
    const appRoot = document.getElementById('app');
    btnTogglePanel.addEventListener('click', () => {
      const collapsed = appRoot.classList.toggle('aside-collapsed');
      btnTogglePanel.setAttribute('aria-pressed', collapsed ? 'true' : 'false');
      setTimeout(() => map.invalidateSize(), 260);
    });
  </script>
</body>
</html>
